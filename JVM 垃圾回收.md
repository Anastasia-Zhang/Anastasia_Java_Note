# 垃圾回收

## JVM 内存

![img](E:\研究生学习\Work\技术笔记\JVM 垃圾回收.assets\640.png)

- 虚拟机栈：描述的是**方法执行时的内存模型**,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建**栈桢**（下文会看到），主要保存执行方法时**的局部变量表、操作数栈、动态连接和方法返回地址**等信息,方法执行时入栈，方法执行完出栈，出栈就相当于清空了数据，入栈出栈的时机很明确，所以这块区域**不需要进行 GC**。
- 本地方法栈：与虚拟机栈功能非常类似，主要区别在于虚拟机栈为虚拟机执行 Java 方法时服务，而本地方法栈为虚拟机执行本地方法时服务的。这块区域也**不需要进行 GC**

* 程序计数器：线程独有的， 可以把它看作是当前线程执行的字节码的行号指示器，比如如下字节码内容，在每个字节码`前面都有一个数字（行号），我们可以认为它就是程序计数器存储的内容记录这些数字（指令地址）

  ![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640.png)我们知道 Java 虚拟机的多线程是通过线程轮流切换并分配处理器的时间来完成的，在任何一个时刻，一个处理器只会执行一个线程，如果这个线程被分配的时间片执行完了（线程被挂起），处理器会切换到另外一个线程执行，当下次轮到执行被挂起的线程（唤醒线程）时，怎么知道上次执行到哪了呢，通过记录在程序计数器中的行号指示器即可知道，所以程序计数器的主要作用是记录线程运行时的状态，方便线程被唤醒时能从上一次被挂起时的状态继续执行，需要注意的是，程序计数器是**唯一一个**在 Java 虚拟机规范中没有规定任何OOM 情况的区域，所以这块区域也**不需要进行 GC**

* 本地内存：线程共享区域，Java 8 中，本地内存，也是我们通常说的**堆外内存**，包含元空间（元空间里有方法区：主要存储已经加载的类的信息、常量、静态变量、即时编译后代码等）和直接内存。
  * 在 Java 8 之前，方法区是放在堆里面的。有个**永久代**的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，主要存储类的信息，常量，静态变量，即时编译器编译后代码等，**这部分由于是在堆中实现的，受 GC 的管理**，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果动态生成类（将类信息放入永久代）或大量地执行 **String.intern** （将字段串放入永久代中的常量区），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。
  * 所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能（发生 GC 会发生 Stop The Word,造成性能受到一定影响，后文会提到），也就不存在由于永久代限制大小而导致的 OOM 异常了（假设总内存1G，JVM 被分配内存 100M， 理论上元空间可以分配 2G-100M = 1.9G，空间大小足够），也方便在元空间中统一管理。综上所述，在 Java 8 以后这一区域也**不需要进行 GC**

* 堆：前面几块数据区域都不进行 GC，那只剩下堆了，是的，这里是 GC 发生的区域！对象实例和数组都是在堆上分配的，GC 也主要对这两类数据进行回收，这块也是我们之后重点需要分析的区域

## 如何识别垃圾

### 引用计数法

对象被引用一次，在它的对象头上加一次引用次数，如果没有被引用（引用次数为 0），则此对象可回收。

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582167392094.png)

无法解决循环引用问题

```java 
public class TestRC {

    TestRC instance;
    public TestRC(String name) {
    }

    public static  void main(String[] args) {
        // 第一步
        A a = new TestRC("a");
        B b = new TestRC("b");

            // 第二步
        a.instance = b;
        b.instance = a;

            // 第三步
        a = null;
        b = null;
    }
}
```

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640.webp)

虽然 a，b 都被置为 null 了，但是由于之前它们指向的对象互相指向了对方（引用计数都为 1），所以无法回收。

### 可达性分析法

可达性算法的原理是以一系列叫做  **GC Root** 的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。（这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 **GC Root** 为起点的引用链中，则这些对象会被判断为「垃圾」,会被 GC 回收。

那么这些 **GC Roots** 到底是什么东西呢，哪些对象可以作为 GC Root 呢，有以下几类

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI（Java Native Interface 即一般说的 Native 方法）引用的对象

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582167594952.webp)

如图示，如果用可达性算法即可解决上述循环引用的问题，因为从**GC Root** 出发没有到达 a,b,所以 a，b 可回收

a, b 对象可回收，就一定会被回收吗?并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当**对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法**，如果未执行，则会先执行 finalize 方法，**我们可以在此方法里将当前对象与 GC Roots 关联**，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！

**注意：** finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!

#### 虚拟机栈中引用的对象

如下代码所示，a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 **GC Root** 的作用，a 与原来指向的实例 **new Test()** 断开了连接，所以对象会被回收。

```java
publicclass Test {
    public static  void main(String[] args) {
        Test a = new Test();
        a = null;
    }
}
```

#### 方法区中类静态属性引用的对象

如下代码所示，当栈帧中的本地变量 a = null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!

```java
public class Test {
    public static Test s;
    public static  void main(String[] args) {
        Test a = new Test();
        a.s = new Test();
        a = null; // a 在第四行指向的对象被回收，此时 s 是静态属性的引用，s 充当的 GC Root的作用
    }
}
```

#### 方法区中常量引用的对象

如下代码所示，常量 s 指向的对象并不会因为 a 指向的对象被回收而回收

```java
public class Test {
	public static final Test s = new Test();
    public static void main(String[] args) {
	    Test a = new Test();
	    a = null;
    }
}
```

#### 本地方法栈中 JNI 引用的对象

本地方法：所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 Java 实现的，可能由 C 或 Python等其他语言实现的， Java 通过 JNI 来调用本地方法， 而本地方法是以库文件的形式存放的（在 WINDOWS 平台上是 DLL 文件形式，在 UNIX 机器上是 SO 文件形式）。通过调用本地的库文件的内部方法，使 JAVA 可以实现和本地机器的紧密联系，调用系统级的各接口方法，还是不明白？见文末参考，对本地方法定义与使用有详细介绍。

当调用 Java 方法时，虚拟机会创建一个栈桢并压入 Java 栈，**而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法**。等到调用本地方法完毕后再进行回收。

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582168248977.webp)

```java
JNIEXPORT void JNICALL Java_com_pecuyu_jnirefdemo_MainActivity_newStringNative(JNIEnv *env, jobject instance，jstring jmsg) {
...
   // 缓存String的class
   jclass jc = (*env)->FindClass(env, STRING_PATH);
}
```

如上代码所示，当 java 调用以上本地方法时，jc 会被本地方法栈压入栈中, jc 就是我们说的本地方法栈中 JNI 的对象引用，**因此只会在此本地方法执行完成后才会被释放**。



## 垃圾回收算法

### 标记-回收算法

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\005b481b-502b-4e3f-985d-d043c2b330aa.png)

在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。

在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

### 标记整理算法

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\ccd773a5-ad38-4022-895c-7ac318f31437-1582169677791.png)

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

优点: 不会产生内存碎片

不足: 需要移动大量对象，处理效率比较低。

### 复制算法

把堆等分成两块区域, A 和 B，区域 A 负责分配对象，区域 B 不分配, 对区域 A 使用以上所说的标记法把存活的对象标记出来），然后把区域 A 中存活的对象都复制到区域 B（存活对象都依次**紧邻排列**）最后把 A 区对象全部清理掉释放出空间，这样就解决了内存碎片的问题了。

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\b2b77b9e-958c-4016-8ae5-9c6edd83871e.png)

不过复制算法的缺点很明显，比如给堆分配了 500M 内存，结果只有 250M 可用，空间平白无故减少了一半！这肯定是不能接受的！另外每次回收也要把存活对象移动到另一半，效率低下（我们可以想想删除数组元素再把非删除的元素往一端移，效率显然堪忧）不足是只使用了内存的一半

#### 复制算法在现代虚拟机中应用

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上 （因为大部分对象在经历一次Minor GC 都会被清理掉），最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

### 分代收集算法

大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收）。

所以分代收集算法根据**对象存活周期的不同**将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1。

这样就可以根据新老生代的特点选择最合适的垃圾回收算法，**新生代选择 复制算法，老年代选择标记整理算法**。新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。

我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582170088431.webp)

#### 1、对象在新生代的分配和回收

对象在创建的时候首先分配在 Eden 区域，当 Eden 区域满时会触发 Minor GC。Minor GC 后只有少部分对象会存活，它们会被移到 S0 区。

**为什么空间大小  Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 ？** 因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余。s0，s1 区域比较小，极大限度的降低了复制算法造成的对象频繁拷贝带来的开销。

**Minor GC 发生过程**

* 利用**复制算法**，首先扫描 Eden 区域和 survivor 需要回收的对象，将 Eden 要存活的对象标记出来
* 将存活的对象复制到 s0 （或者s1）区域，此时这些对象的年龄加一（经历过一次MinorGC年龄增加1岁）
* 清除 Eden 和 s0 （或者s1） 区域
* 每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582170716065.gif)

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582171358615.gif)

#### 2、对象如何进入到老年代

当年龄到达15岁时直接进入老年代

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640.gif)

* 大对象：当每个对象分配需要大量的连续内存时（数组、字符串），此时对象的创建不会分配到 Eden 区域，而是直接分配到老年代。（避免Minor GC 复制带来的开销和沾满 s1 s0 区域）
* 动态对象创建判断（在一直动态的创建对象的情况下）： `Survivor`  中年龄相同的对象大小之和大于 他的空间一半时，则年龄大于等于该年龄的对象会晋升到老年代

#### 3、空间分配担保

在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的。如果不大于，那么虚拟机会查看HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小（根据平均预测），如果大于则进行 Minor GC，否则可能进行一次 Full GC

```java 
while (before(Minor GC)){
    // 老年代最大可用的连续空间是否大于新生代所有对象的总空间
	if (sizeOf(MaxAvaiableSizeOfOld) > sizeOf(YongObject)){
        MinorGC;
    }else{
        // 允许担保失败
        if (HandlePromotionFailure){
            // 老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小
            if (sizeOf(MaxAvaiableSizeOfOld) > sizeOf(AverageYongToOld)){
                MinorGC;
            }else {
                FullGC;
            }
        }
    }
}
```

#### 4. Stop the World

如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。

什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。

一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理**整个堆**中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）

**JVM 优化策略**

现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了**尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC**。

**为什么设置 Survivor 区域**

想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0, S1的缓冲，只有少数的对象不会过早的进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。

**什么时候 Full GC**

由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，这个**时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷**。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置（在此位置当前对象的状态是可以确定的）：

- 循环的末尾
- 方法返回前
- 调用方法的 call 之后
- 抛出异常的位置 

## 垃圾回收器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582173363927.png)

- 在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge
- 在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old
- 同时在新老生代工作的垃圾回收器：G1

图片中的垃圾收集器如果存在连线，则代表它们之间可以配合使用，接下来我们来看看各个垃圾收集器的具体功能。

### 新生代收集器

#### Serial 收集器

* **特点：** 新生代标记复制算法、**单线程**，只会用会使用一个 CPU 或一个收集线程来完成垃圾回收
* **应用场景：** **Client 模式** 。它简单有效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 单线程模式无需与其他线程交互，减少了开销，专心做 GC 能将其单线程的优势发挥到极致，所以对于运行在 Client 模式下的虚拟机，Serial 收集器是新生代的默认收集器



#### ParNew 收集器

ParNew 收集器是 Serial 收集器的**多线程**版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完成一样，在底层上，这两种收集器也共用了相当多的代码。

* **特点：** 新生代标记回收算法，多线程，**唯一能与 CMS（第一个并发的垃圾收集器，用户线程和垃圾收集线程同时工作） 垃圾收集器结合使用的收集器**（采用同一套代码框架）
* **应用场景：** 服务端，与CMS配合使用；多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。

但是 后来登场的 G1 垃圾收集器更先进，他不需要其他垃圾收集器配合工作。JDK 9 之后自然 CMS 和 ParNew 被取代，ParNew 本来点价值就是和 CMS 使用，现在就尴尬了。



#### Parallel Scavenge 收集器

Parallel Scavenge 收集器也是一个使用**复制算法**，**多线程**，工作于新生代的垃圾收集器

* **特点：** **关注点不同**，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 **Parallel Scavenge 目标是达到一个可控制的吞吐量**（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间））

* **应用场景**：CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，可以最高效率的利用处理器资源，尽快的完成程序的运算任务。所以**更适合做后台运算等不需要太多用户交互的任务**



Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）

除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！



### 老年代收集器

#### Serial Old 收集器

* **特点：** Serial Old 是工作于老年代的单线程收集器

* **应用场景**：
  *  Client 模式下的虚拟机使用
  * Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582173363930.png)

#### Parallel Old 收集器

Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，**真正实现了「吞吐量优先」的目标**

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582173363970.png)

#### CMS 收集器

CMS 收集器是以**实现最短 STW 时间为目标的收集器**，如果应用很重视服务的响应速度，希望给用户最好的体验，则 CMS 收集器是个很不错的选择！

我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤

1. **初始标记**：会造成 STW 初始标记仅标记 GC Roots 能关联的对象，速度很快
2. **并发标记**：就是从 GC Roots 直接关联对象开始遍历整个对象图的过程，过程比较长，**可以与垃圾收集线程并发进行**
3. **重新标记**：会造成STW  为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，比初试标记时间稍微常，远远比并发标记时间短，
4. **并发清除**：清除那些标记阶段已经死去的对象，**并发执行**

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582173363935.webp)



但是 CMS 收集器远达不到完美的程度，主要有以下三个缺点

- **CMS 收集器对 CPU 资源非常敏感** 

   原因也可以理解，比如本来我本来可以有 10 个用户线程处理请求，现在却要分出 3 个作为回收线程，吞吐量下降了30%，CMS 默认启动的回收线程数是 （CPU数量+3）/ 4, 如果 CPU 数量只有一两个，那吞吐量就直接下降 50%,显然是不可接受的

- **CMS 无法处理浮动垃圾（Floating Garbage）**

  可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在**并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾）**

  同时在垃圾收集阶段用户线程也要继续运行，**就需要预留足够多的空间要确保用户线程正常执行**，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，JDK 1.5 默认当老年代使用了68%空间后就会被激活，当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 **Concurrent Mode Failure** 失败，**这时会启用 Serial Old 收集器来重新进行老年代的收集**，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。

- **CMS 采用的是标记清除法，会产生大量的内存碎片**，**如果无法找到足够大的连续空间来分配对象，将会触发 Full GC**

  我们可以开启 -XX:+UseCMSCompactAtFullCollection（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。

  

#### G1（Garbage First） 收集器

G1 收集器是面向服务端的垃圾收集器，被称为驾驭一切的垃圾回收器，主要有以下几个特点

- 像 CMS 收集器一样，能与应用程序线程并发执行。

- 整理空闲空间更快。

- 需要 GC 停顿时间更好预测。

- 不会像 CMS 那样牺牲大量的吞吐性能。

- 不需要更大的 Java Heap

  

与 CMS 相比，它在以下两个方面表现更出色

1. 运作期间不会产生内存碎片，G1 从整体上看采用的是标记-整理法，局部（两个 Region）上看是基于复制算法实现的，两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。
2. 在 STW 上建立了**可预测**的停顿时间模型，用**户可以指定期望停顿时间，G1 会将停顿时间控制在用户设定的停顿时间以内**。

为什么G1能建立可预测的停顿模型呢，主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一器，传统的内存分配就像我们前文所述，**是连续的**，分成新生代，老年代，新生代又分 Eden,S0,S1,如下

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582173363945.webp)

而 G1 各代的存储地址不是连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个Region占有一块连续的虚拟内存地址，如图示。每个 Region 根据需要来扮演新生代的 Eden、Survivor 或者老年代空间。收集器能够给根据不同的角色去采用不同的策略进行垃圾收集

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582173363946.webp)

除了和传统的新老生代，幸存区的空间区别，Region还多了一个H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象。这样超大对象就直接分配到了老年代，防止了反复拷贝移动。那么 G1 分配成这样有啥好处呢？

传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集，而分配成各个 Region 

* 将 Region 作为单次回收的最小单元，每次收集到的内存空间都是 Region 大小的整数倍
* 方便 G1 跟踪各个 Region 里垃圾堆积的价值大小（回收所获得的空间大小及回收所需经验值），这样根据价值大小维护一个优先列表，根据允许的收集时间，**优先收集回收价值最大的 Region**

* **避免了整个堆内存的回收，也就减少了 STW 造成的停顿时间。同时由于只收集部分 Region,可就做到了 STW 时间的可控**。

G1 收集器的工作步骤如下（除了并发标记外取余阶段也需要暂停线程

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收：对各个Region 回收价值和成本进行排序，根据用户期望的停顿时间来指定回收计划，可以任意多个 Region 进行回收，把存活对象复制到空的 Region 中， 清理掉就的 Region 全部空间

![img](E:\研究生学习\Work\技术笔记\Untitled.assets\640-1582173363971.png)

可以看到整体过程与 CMS 收集器非常类似，筛选阶段会根据各个 Region 的回收价值和成本进行排序，根据用户期望的 GC 停顿时间来制定回收计划。

生产环境中我们要根据**不同的场景**来选择垃圾收集器组合，如果是运行在桌面环境处于 Client 模式的，则用 Serial + Serial Old 收集器绰绰有余，如果需要响应时间快，用户体验好的，则用 ParNew + CMS 的搭配模式，即使是号称是「驾驭一切」的 G1，也需要根据吞吐量等要求适当调整相应的 JVM 参数，没有最牛的技术，只有最合适的使用场景，切记！



## 参考

* https://mp.weixin.qq.com/s/8vXENzg580R7F2iNjSdHFw
* 《深入理解 Java 虚拟机》 第三版