# 类加载

类对象的创建和分配：

类加载检查  （检查该指令的参数是否能在常量池找到其符号引用，是否被加载过）

分配内存 

初始化零值 

设置对象头  将指针指向分配的内存地址

执行init方法

#### 我们写好的 `.java`  文件如何运行？

首先将写好的“.java”代码文件，**编译**成 “.class” 字节码文件，然后**类加载器**把 “.class” 字节码文件中的类给**加载到JVM中**，接着是 JVM 来执行我们写好的那些类中的代码

字节码文件主要包含了该类的相关信息，如常量、字段、方法、继承等信息

## 类加载的过程

**加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载**

* 验证、准备、解析过程又称为连接
* 加载、验证、准备、初始化、使用 是严格按照这种顺序按部就班的 **开始**
* 解析阶段可能在初始化阶段后进行，如Java语言的运行时绑定

##### 类加载的时机

虚拟机没规定，但是规定了5条虚拟机必须立即初始化的阶段（稍后介绍）

### 1. 加载

主要完成 3 件事情

1. **通过**全类名获取定义此类的**二进制字节流**
2. 将字节流所代表的**静态存储结构转换**为方法区的**运行时数据结构**
3. 在内存中生成一个代**表该类的 Class 对象**,作为方法区这些数据的访问入口

虚拟机规范多上面这3点并不具体，因此是非常灵活的。比如："通过全类名获取定义此类的二进制字节流" 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等

#### 数组类加载

* 通过JVM直接创建
* 元素类型（去掉所有的维度，最基本的组成单位）：由加载器创建
* 组件类型（去掉一维）
  * 引用类型：递归之前定义的加载过程去加载，可见性和组件一致
  * 非引用类型：与引导加载器相关联 可见性默认为public

#### 非数组类型加载

* 具有更好的可控性，既可以使用系统提供的引导类加载器加载，也可以自己重写`loadClass` 方法

### 2. 验证

确保Class 文件的字节流包含的信息符合当前虚拟机的要求

![验证阶段](E:\研究生学习\Work\技术笔记\JVM：类加载.assets\验证阶段.png)

符号引用验证是在虚拟机将符号引用转化为直接引用的时候，这个转化的动作在解析阶段发生、符号引用验证可以看做是对自身类之外（常量池中各种符号的引用）信息的匹配性校验

> **符号引用** ：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，**符号引用和虚拟机的布局无关**。个人理解为：在编译的时候一个每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址，多以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。
>
> **直接引用** ：**直接引用和虚拟机的布局是相关的**，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。如果有了直接引用，那么直接引用的目标一定被加载到了内存中。
>
> 直接引用可以是： 
>
> 1：直接指向目标的指针（个人理解为：指向对象，类变量和类方法的指针）
>
> 2：相对偏移量（指向实例的变量，方法的指针）
>
> 3：一个间接定位到对象的句柄



### 3. 准备

正式为类变量分配内存并设置初始值，这些变量所使用的内存都在方法区分配

**类变量**：被 static 修饰的变量，不包括实例变量

**初始值**：一般情况下零值 (如果类字段的属性表中存在常量值ConstantValue属性，会在准备阶段把变量初始化为ConstantValue) 值 final



### 4. 解析

是将虚拟机常量池内的**符号引用转换为直接引用**

#### 1. 类或接口的解析

设当前代码所处的类是D，如果要把一个未解析过的符号引用N解析为一个类或这接口C的直接引用

1. **C不是数组类型**：虚拟机会把符号引用N的全限定名传递给D的类加载器去加载C，若加载出现异常，则解析过程失败
2. **C是数组类型，数组的元素类型为对象**：虚拟机先**加载**数组元组类型，细腻接生成代表此数组维度和元素的数组对象
3. 上面步骤没有异常，那么 C 在虚拟机中已经成为一个有效的类或接口了。但在解析之前还要完成符号引用验证，确认D 是否 具备对 C 的访问权限 `java.long.IllegagAccessError`

#### 2. 字段解析

首先对字段表内 `class_index ` 索引的 `CONSTANT_Class_info` 的符号引用进行解析，即字段所属类或接口的符号引用，若解析完成，这个字段所属的类为C，则JVM按照下列字段对C的后续字段进行搜索，结束标志为是包含简单名称和字段描述符都与目标匹配的字段

1. C 本身包含简单名称和字符描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束
2. 在C 中实现了接口的话，按照继承关系从下往上递归搜索各个接口和他的父接口，如果接口中含有，结束
3. C 不是 Object 继承关系搜索父类，若父类中含有，则结束
4. 否则查找失败 `java.long.NoSuchFieldError` 异常

查找成功还有权限验证，若字段在接口和父类中同时存在重名字段，则拒绝编译

#### 3. 类方法解析

首先对类方法表内 `class_index `  索引的方法或接口的符号引用，如果解析成功，C 代表这个类，虚拟机将按照下列步骤进行搜索 ，结束标志是否包含简单名称和描述符都与目标匹配的类方法

1. 类方法和接口方法的符号引用类型定义是分开的，若在类方法中发现 `class_index ` 索引中索引的是个接口，则抛出 `java.long.IncompatibleClassChangeError` 异常
2. 在 类C 中查找，符合条件则结束
3. 在 类C 的父类中递归查找，符合条件则结束
4. 在 类C实现的接列表递归查找。如果存在相匹配的方法说明C是个抽象类，查找结束，抛出 `java.long.AbstractMethodError`
5. 宣告方法失败，抛出 `java.long.NoSuchMethod` 异常

成功返回直接引用，还要对方法进行权限验证

#### 4. 接口方法解析

先解析接口方法表的 `class_index` 项索引的方法所属类或接口的符号引用，解析成功 用 C 表示这个接口。然后按照下列步骤进行后续的接口方法搜索

1. 若在接口方法中发现 `class_index ` 索引中索引的是个类，则抛出 `java.long.IncompatibleClassChangeError` 异常
2. 在接口C中查找，符合条件结束
3. 在接口C的父接口中递归查找，直到Object类，查看是否有简单名称和描述符都与目标匹配的方法，有则返回这个方法的直接引用
4. 否则查找失败，抛出 `java.long.NoSuchMethod`

都在 public 的不存在访问权限问题

### 5. 初始化

前面类加载过程中，除了在加载阶段用户程序可以通过自定义的类加载器参与以外，其余动作全由虚拟机主导控制

准备化阶段变量被赋的是零值，初始化阶段被赋的值是程序指定的值

**初始化阶就是执行类构造器`<clinit>()`方法的过程**

#### `<clinit>()`方法

##### 什么是 `clinit<>()` 方法？

* 他是编辑器 `javac` 的自动生成物，是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句结合产生的。
* 说白了，`clinit<>()` 方法主要包含两个部分，一个是所有类变量的赋值操作，另一个是 `static{}` 中的语句

##### 顺序是什么？

收集的顺序按照语句在源文件中出现的顺序。

其中，有一点比较特殊，就是 `clinit<>()` 方法在静态语句块中只能访问到定义静态语句块之前的变量，定义之后的变量在前面的静态语句块内可以赋值，但不能访问。这就是**非法向前引用**。

```java 
public class Test{
    static{
        i = 0; // 可以赋值，但是不能访问
        System.out.print(i); // 非法向前引用,访问该变量的时候还没进行初始化
    }
    static int i = 1; // 定义在静态语句块之后的变量
}
```

> ##### 什么是非法向前引用？为什么要规定非法向前引用（illegal forward reference）？
>
> 在类加载准备阶段：正式为类变量分配内存并设置初始值，当访问到i的时候，还未初始化赋值，所有Java为了保护变量不让我们访问到变量的 ”零值“。Java允许**通过简单名称引用的变量可以出现在左值位置，但不能出现在右值的位置**。这也是为了避免循环初始化和其他非正常初始化的行为。

*  `clinit<>()`  该方法与类的构造函数不同，他不需要显式的调用父类构造器，因为在子类的 `<clinit>()` 方法执行之前，父类的 `clinit<>()` 已经执行完毕。在JVM中第一个被执行的 `clinit<>()`  的类肯定是 Object 类
* 父类的 `clinit<>()`方法先执行，意味着父类定义的静态语句块优先于子类变量的赋值操作

##### 几点问题

* `clinit<>()` 对于类和接口来说不是必须的，从前面可以看出，这个方法与类变量和静态方法有关系，如果一个类中没有静态语句块，没有赋值操作，那么编译器也就不会生成该方法。
* 前面说到，执行子类的 `clinit` 方法前，父类的 `clinit<>()`方法先执行。但是接口与类不同。执行接口的 `clinit<>()` 方法不需要先执行父接口的该方法，因为只有父接口中定义的变量被使用到后，父接口才会被初始化，接口的实现类也同理。
* 多个线程同时初始化一个类，那么只有一个线程会去执行该类的 `clinit<>()` 方法，其他线程都需要阻塞等待。

#### 常见的主动引用


虚拟机规定以下5种情况必须初始化，以下五种阶段也称为 **主动引用**

对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化：

1. 当遇到 `new 、getstatic、putstatic`或 `invokestatic` 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
2. 使用 `java.lang.reflect` 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。（接口初始化时并不要求父接口全部初始化，真正用到时才初始化  `<clinit>()` 构造器
4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。
5. 当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化

#### 常见的被动引用

* 子类调用父类的静态变量时，子类不进行初始化

* 通过数组定义引用表时，不发生初始化

  此时会发生 [LXXX.XXX.XXX.(包名).class(类名)的初始化，但在用户代码里这是一个非法的名称，他是由虚拟机在自动生成，继承于Object 的子类，由 `newarray` 触发

  由且该方法代表是这个类的数组，只含有数组的 public 的方法 如 length 和 clone 方法

* 当类直接调用某个类的常量时，不会发生定义常量类的初始化

  ```java 
  public class ConstClass{
  	static{
          System.out.println("init");
      }
      public static final String HELLOWORLD = "hello world";
  }
  
  public class Main{
      public static void main(String[] args){
          System.out.println(ConstClass.HELLOWORLD);
      }
  }
  
  -----Output------
  hello world
  ```

  因为，常量在编译的时候会存在被**调用类**的常量池中，以后这个Main类对常量的 `ConstClass.HELLOWORLD` 的引用都会转变为自己对他的引用。因为Main 的Class 文件之中并没有 ConstClass 的符号引用入口，这两个类在编译成Class 之后就不存在任何联系了

  