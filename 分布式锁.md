# 分布式锁

## Redis 分布式锁

Redis 官方叫做 RedLock 算法，是 Redis 官方支持的分布式锁的算法

分布式锁的三个要点：

* 互斥（只有一个客户端可以获取锁)
* 不能上锁
* 容错（大部分 redis 结点或者这个锁可以加可以释放）

### 1. 最普通的实现方式在 Redis 里创建一个 key 加锁 

`set my:lock 随机值 NX PX 30000  ` NX（只有key不存在的时候才能成功）PX 30000毫秒自动释放锁

![01_redis最普通的分布式锁的实现原理](E:\研究生学习\Work\技术笔记\分布式锁.assets\01_redis最普通的分布式锁的实现原理.png)





* 如果系统想要获取数据，就执行 `set my:lock 随机值 NX PX 30000  `  语句去加锁，实际上就是设置一个 key 。如果没有设置这个 key  那就设置成功，redis 就返回 ok；若redis中有这个key 那么设置失败，redis返回 nil。到了 30 s 之后自动删除

* 这样当别的系统想要再获取这个数据的时候，也会执行这个set语句，如果没有拿到这把锁，就需要每隔 1s 自动尝试去看是否能拿到这把锁。

* 锁的删除就是执行 lua 脚本

  ```lua
  if redis.call("get",KEYS[1]) == ARGB[1] then
      return redis.call("del",KEYS[1])
  else
      return 0
  end
  ```

  删除锁的时候会找到对应锁的 key 的 value。和自己传过去的 value 作比较，一样的话就会删除这个 key。

* **为什么要设置随机值？**如果某个客户端获得了锁，但是阻塞了很长时间才执行完，此时可能自动释放锁了。释放锁之后别的客户端就拿到了这个锁。这个时候如果直接删除这个key 的话会把别的客户端的锁也会删除（删掉别人的锁了）。

#### 存在的问题

单节点故障：如果是普通的 redis 单实例，那就是单点故障。或者是redis 普通的主从，redis主从异步复制，如果主节点挂了，主节点上的 key 还没有同步到从结点（异步同步），别人也会加锁

### 2. RedLock 算法

假设场景有一个 redis cluster，有 5 个 redis master 实例。进行如下步骤获取一把锁

1. 获取当前时间戳，ms
2. 轮流尝试在每个 master 结点创建锁， 过期时间较短 几十毫秒
3. 尝试在大多数结点上建立一个锁，（n / 2 + 1)
4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功
5. 建立失败，依次删除锁 （使用lua 脚本）
6. 只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁

防止单个 redis 结点宕机

### 3. Redisson 开源框架实现分布式锁

下面给大家看一段简单的使用代码片段，先直观的感受一下：

![img](E:\研究生学习\Work\技术笔记\分布式锁.assets\640-1582445443531.png)

![img](E:\研究生学习\Work\技术笔记\分布式锁.assets\640-1582445521710.webp)

#### （1）加锁机制

客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。

紧接着，就会发送一段lua脚本到redis上，那段lua脚本如下所示：

![img](E:\研究生学习\Work\技术笔记\分布式锁.assets\640-1582445582455.webp)



**为啥要用lua脚本呢？**

因为一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的**原子性**。



**lua脚本是什么意思呢？**

**KEYS[1]**代表的是你加锁的那个key，比如说：`RLock lock = redisson.getLock("myLock");`这里你自己设置了加锁的那个锁key就是“myLock”。

**ARGV[1]**代表的就是锁key的默认生存时间，默认30秒。

**ARGV[2]**代表的是加锁的客户端的ID，类似于下面这样：`8743c9c0-0795-4907-87fd-6c719a6b4586:1`

给大家解释一下，第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。

如何加锁呢？很简单，用下面的命令：`hset myLock 8743c9c0-0795-4907-87fd-6c719a6b4586:1 1`

通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：

![img](E:\研究生学习\Work\技术笔记\分布式锁.assets\640-1582445582459.webp)



上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。

接着会执行`“pexpire myLock 30000”`命令，设置myLock这个锁key的生存时间是30秒。

好了，到此为止，ok，加锁完成了。

**总之：先判断锁是否存在，不存在的话加锁，设置生存时间**

#### （2） 互斥锁机制

那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？

第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。

接着第二个if判断，**判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID**，但是明显不是的，因为那里包含的是客户端1的ID。if 条件不成立。

所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key的**剩余生存时间。**比如还剩15000毫秒的生存时间。

此时客户端2会进入一个while循环，不停的尝试加锁。

**总之：另外一个客户端会执行一样的lua脚本去查看那个锁是否存在，不存在的话获取锁的客户端ID是否等于自己的ID，如果不等于的话就返回锁的剩余生存时间，此时客户端2会一直不停的尝试进行加锁**



#### （3）watch dog 自动延期机制

客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？

简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，**他是一个后台线程，会每隔10秒检查一下**，如果客户端1还持有锁key，那么就**会不断的延长锁key的生存时间**。



#### （4） 可重入锁机制

如果已经持有这把锁了，那么可重入!锁的加锁会是什么样子

![img](E:\研究生学习\Work\技术笔记\分布式锁.assets\640-1582447864447.png)

继续分析上面那段脚本：

第一个if判断肯定不成立，“exists myLock”会显示锁key已经存在了。

第二个if判断会成立，因为 myLock 的 hash 数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1”

此时就会执行可重入加锁的逻辑，他会用：`hincrby myLock 8743c9c0-0795-4907-87fd-6c71a6b4586:1 1`通过这个命令，对客户端1的加锁次数，累加1。

此时myLock数据结构变为下面这样：

![img](E:\研究生学习\Work\技术笔记\分布式锁.assets\640-1582448074602.webp)

大家看到了吧，那个myLock的hash数据结构中的那个客户端ID，就对应着加锁的次数

#### （5）释放锁机制

如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。

其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。

如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：“`del myLock`”命令，从redis里删除这个key。另外的客户端2就可以尝试完成加锁了。

#### 缺点

他的复制是**主从异步复制，**当主备切换的时候，在原来Master结点上加上的锁还没复制到新的主节点，此时客户端2想要从新的主节点加锁就会成功，造成了多个客户端对一个分布式锁完成了加锁。**会导致各种脏数据的产生**。

在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。



## Zookpooer 分布式锁

### 1. 最基本的实现原理

![03_zookeeper的分布式锁原理](E:\研究生学习\Work\技术笔记\分布式锁.assets\03_zookeeper的分布式锁原理-1582440247869.png)



### 2. 基于Zookeeper 的临时顺序结点

基于 `Curator` 开源框架，创建临时顺序结点。

简单来说，就是直接在"my_lock"这个锁节点下，创建一个顺序节点，这个顺序节点有zk内部自行维护的一个节点序号。

比如说，第一个客户端来搞一个顺序节点，zk内部会给起个名字叫做：xxx-000001。然后第二个客户端来搞一个顺序节点，zk可能会起个名字叫做：xxx-000002。大家注意一下，**最后一个数字都是依次递增的**，从1开始逐次递增。zk会维护这个顺序。

* 客户端想要获取锁，在要加锁的 node 结点下先创建顺序临时结点

  ![img](E:\研究生学习\Work\技术笔记\分布式锁.assets\640.png)

* 客户端A或查找这个结点下的顺序结点结合，来判断在顺序结点集合里面的第一个顺序结点是不是自己创建的，如果是则加锁成功

![img](E:\研究生学习\Work\技术笔记\分布式锁.assets\640.jfif)

* 客户端 B 也想加锁，这个时候也是会在 锁结点下创建一个临时顺序结点，再去获取my_lock 锁结点下获取所子节点，看第一个子节点是否是自己创建的。不是加锁失败。

* 这个时候客户端B就对他的上一个顺序结点加入一个监听器，zk可以实现对某个结点的监听

  ![img](E:\研究生学习\Work\技术笔记\分布式锁.assets\640.webp)

* 等到 A 释放锁的时候，也就是把他创建的临时顺序结点个删除。

* 这个时候 B 监听到 临时顺序结点的变化，通知给 B ，B再去执行加锁的逻辑看看所有的临时顺序结点的集合，自己创建的结点是不是第一个，是的话则加锁成功

  ![img](E:\研究生学习\Work\技术笔记\分布式锁.assets\640-1582442198355.jfif)

## 二者比较

Redis 分布式锁，需要自己不断尝试去获取锁，比较消耗性能

zk 分布式锁，获取不到锁的话，注册个监听器即可，不需要不断主动尝试获取锁，性能开销比较少

redis 获取锁的客户端出 bug 了或者挂掉，只能等待超时时间之后才能释放锁；zk的客户端挂掉，由于创建的是 临时 znode， 只要客户端挂掉了，zk自动把这个 znode 就没有了，此时会自动释放锁。