# Synchronized

### 基本使用

- **修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁**

- **修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁** 。

  也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。

  所以如果一个线程A调用**一个实例对象**的**非静态** synchronized 方法，而线程B需要调用这个**实例对象所属类**的**静态** synchronized 方法，是允许的，不会发生互斥现象，**因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。

- **修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。** 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！

> 只要修饰静态的就相当于给当前类上了锁

### 底层原理（字节码层面）

#### 修饰代码块

javac 编译后，会形成  `monitorenter` 和 `monitorexit` 指令

* 在同步代码块中，JVM通过 monitorenter 和 monitorexist 指令实现同步锁的获取和释放功能
* monitorenter指令是在编译后插入到同步代码块的开始位置
* monitorexit指令是插入到方法结束处和异常处
* JVM要保证每个monitorenter必须有对应的monitorexit与之配对
* 任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态
* 线程执行monitorenter指令时，将会尝试获取对象所对应的monitor的所有权 （当锁计数器为0的时候可以获取），即尝试获得对象的锁，获取成功后，锁的计数器 + 1
* 线程执行monitorexit指令时，将会将进入次数 -1直到变成 0 时释放监视器
* 同一时刻只有一个线程能够成功，其它失败的线程会被阻塞，并放入到同步队列中，进入BLOCKED状态

#### 修饰方法

使用 `ACC_SYNCHRONIZED` 表示来判断是否是一个同步方法。

* 原理是通过方法调用指令检查该方法在常量池中是否包含 ACC_SYNCHRONIZED 标记符，如果有，JVM 要求线程在调用之前请求锁

### 对象的内存布局

在JVM中，对象在内存中的布局分成三块区域：对象头、示例数据和对齐填充

- 对象头： 对象头主要存储对象的hashCode、锁信息、类型指针、数组长度(若是数组的话)等信息
- 示例数据：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组长度，这部分内存按4字节对齐
- 填充数据：由于JVM要求对象起始地址必须是8字节的整数倍，当不满足8字节时会自动填充（因此填充数据并不是必须的，仅仅是为了字节对齐）

synchronized 用的锁是存在Java对象头里的。那么什么是 Java 对象头呢？**Hotspot 虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）**。其中：

**Mark Word 用于存储对象自身的运行时数据**，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。

**类型指针** 对象指向他的类型元素的指针，通过这个指针来确定对象是哪个类的实例

Object  object = new Object(); 包含多少个字节？

对象头一般8个字节 类型指针4（压缩）字节 剩下的对齐 12 +4 字节 凑够8字节的整数倍 一共16个字节（开启压缩）

没有开启压缩：MarkWord 8 + Kclass Pointer 8 无对齐 16字节 

若加一个 int  一个 String  成员变量呢？

int 4 字节 + String 类型指针 4字节（压缩）+ MarkWord 8 + Kclass Pointer 4 (压缩)  + 4 填充数据 = 24字节

压缩？JVM 64位 指针长度就是64位 8个字节 会把8个字节压缩成4个字节 因此类型指针压缩后4个字节

![image-20200225102930571](E:\研究生学习\Work\技术笔记\Synchronized.assets\image-20200225102930571.png)

#### 不同锁状态下的对象头布局

![markword-64](E:\研究生学习\Work\技术笔记\Anastasia_Java_Note\Synchronized.assets\markword-64.png)

### JDK 1.6 之后的锁优化

JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

**锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。**

#### 自旋锁

互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。

**一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的，尤其是贡献数据的锁定状态都是很短的。** 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。**为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋**。

应用场景：锁被占用时间很短的情况下

如果锁被占用时间很长，那么在自旋的时候会占用处理器的时间，如果自旋的次数超过 10 次，那么就要挂起线程。

#### 自适应自旋锁

由于自旋锁只能指定固定的自旋次数，但由于任务的差异，导致每次的最佳自旋次数有差异

JDK 6 中对锁的自旋做了优化。**即可以自动调整自旋时间；这个时间取决于前一次某个线程在同一个锁上自旋的时间和锁的拥有者所处的状态决定的**。如果在同一个锁对象上，自旋时间很短就获得了该对象，并且现在持有锁的进程正在运行，那么JVM可能认为再一次自旋会成功的几率很大，进而运行自旋等待更长的时间。

#### 锁消除

锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间

- 痛点：根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加
- 锁原理： JVM在编译时通过对运行上下文的描述，去除不可能存在共享资源竞争的锁，通过这种方式消除无用锁，即删除不必要的加锁操作，从而节省开销
- 使用： 逃逸分析和锁消除分别可以使用参数-XX:+DoEscapeAnalysis和-XX:+EliminateLocks(锁消除必须在-server模式下)开启
- 补充：在JDK内置的API中，例如StringBuffer、Vector、HashTable都会存在隐性加锁操作，可消除



#### 锁粗化

原则上，我们再编写代码的时候，总是推荐将同步快的作用范围限制得尽量小——只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。

大部分情况下，上面的原则都是没有问题的，**但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗**。如 StringBuilder 连续的append 操作，因为每一次 append 操作都是 同步的，那么就可以扩大至刚开始 append 操作 和 append 操作结束。



#### 轻量级锁

**重量级锁**是通过对象内部的监视器实现；监视器的本质还是依赖于操作的系统底层的互斥信号量。操作系统实现线程之间的切换，需要用户态到核心态的切换，切换成本比较高。如果尝试获取去锁成功，就占用，若不能获取成功，就睡眠等待。

轻量级锁不是为了代替重量级锁，它**的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗**，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。

> 轻量级锁的加锁过程
>
> * 在代码进入同步块的时候，如果同步对象还没有锁定，JVM会将当前对象的 Mark Word **拷贝** 至当前线程的栈帧空间里，这个空间叫 Lock Record
> * CAS 将当前对象的 Mark Word 指向 Lock Record 
> * 成功则代表该线程拥有的这个对象的锁，这个锁处于轻量级锁（修改标志位 00 ）
> * 失败，检查当前对象的 Mark Word 是否指向当前线程的栈帧（Lock Record）
> * 如果是则重入这个代码块
> * 不是，说明当前锁对象被其他线程占有了，当前线程遍尝试使用自旋获取锁。若自旋后没有获得锁，就膨胀为重量级锁
>
> 轻量级锁的释放过程
>
> * CAS 交换 ，如果对象的 Mark Word 仍然指向线程栈中的Lock Record，那么就将当前线程的 Mark Word 和 线程栈中之前复制的 Displaced Mark Word 替换，成功则解锁。
> * 失败则说明其他线程尝试过获取锁，就要在释放锁的同时挂起锁



轻量级锁能够提升程序同步性能的依据是“**对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据**。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！

#### 偏向锁

在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。**偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗**。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。

偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！

> 获取过程：
>
> 1. 如果锁对象第一次被线程获取的时候，虚拟机会将对象头部的锁的标志位设置为 01 偏向模式设置为1 ，表示进入偏向模式
> 2. CAS操作把获取到这个锁的线程ID记录到锁对象的头部 Mark Word 当中
> 3. 成功，持有偏向锁的时候每次进入到这个线程的同步块的时候，虚拟机可以不用再进行任何的同步操作（加锁、解锁、Mark Word 的更新操作）
> 4. 如果任何一个线程去尝试获得锁，偏向模式立马宣告结束。根据锁对象目前的锁定状态进行相应的操作



![IMG_20200225_102827](E:\研究生学习\Work\技术笔记\Synchronized.assets\IMG_20200225_102827.png)

但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。

**当锁进入偏向状态的时候，Mark Word 的大部分空间都用于存储持有锁的线程ID了，原来对象的哈希码怎么办？**

如果一个对象计算过哈希码，就应该一直保持不变（推荐不强制）。对象的哈希吗在经过一次计算时，就在对象的头部存储计算的结果，也就是说：**对象头部存在的哈希码是为了每次计算的结果保持一致性的，经过一次计算后存储在对象头部，这样下次再计算后取得的哈希值是永远不变的**。因此当一个对象计算过一次哈希码的时候就不能进入偏向锁的状态了；当以对象处于偏向锁的状态时，又收到计算其计算一致性哈希码的请求后（调用Object.hashCode() 方法，不包括重写），就会撤销偏向锁状态，膨胀成重量级的锁。

**对比**

- 由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗（这个通常只能通过大量压测才可知）
- 对比：轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能

### 实现过程

* 字节码层面 `monitorenter ` 和 `monitorexit`
* 执行过程中自动升级
* 指令层面 `lock cmxchg`