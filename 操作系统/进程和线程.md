# 进程、线程的区别和使用场景

## 1. 进程

- 进程是**系统进行资源分配和调度**的一个独立单位 。

- 程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。

- 在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。

  进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。

## 2. 线程

- 引入：为什么需要线程
  - 进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。
  - 进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。所以引入更加细一级的线程，使得以一个进程也可以做很多事情。
  - **为了更好的使多道程序并发执行，提高资源利用率和吞吐量，增加程序的并发性**。
- 线程是进程的一个实体，是**CPU调度和分派的基本单位**，它是比进程更小的能独立运行的基本单位。

## 3. 区别与联系

### 【区别】：

- **调度：**线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；

- **并发性：**不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；

- **拥有资源**：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。**进程所维护的是程序所包含的资源（静态资源）**， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；**线程所维护的运行相关的资源（动态资源）**，如：运行栈，调度相关的控制信息，待处理的信号集等；

  ![image-20200705170722090](E:\研究生学习\Work\技术笔记\Anastasia_Java_Note\操作系统\进程和线程.assets\image-20200705170722090.png)

- **系统开销**：有单独的地址空间。

  - 在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。
  - 但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。
  - 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。

### 【联系】：

- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；

- **资源分配给进程**，同一进程的所有线程共享该进程的所有资源；
- **处理机分给线程**，即真正在处理机上运行的是线程；
- 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。
  

使用CPU亲缘性的好处：**设置CPU亲缘性是为了防止进程/线程在CPU的核上频繁切换**，从而**避免因切换带来的CPU的L1/L2 cache失效**，cache失效会降低程序的性能。

### 协程

协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

  子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，**一个线程就是执行一个子程序**。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。

  **协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。**

```python
def A():
    print '1'
    print '2'
    print '3'

def B():
    print 'x'
    print 'y'
    print 'z'
```

  假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：1 2 x y 3 z。

  协程的特点在于是一个线程执行，那和多线程比，协程有何优势？

**极高的执行效率**：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；

**不需要多线程的锁机制**：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。


## 4. 多进程和多线程的使用场景

| 对比维度       | 多进程                                                       | 多线程                                                       |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据共享、同步 | 数据共享复杂，需要用IPC；数据是分开的，同步简单              | 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 |
| 内存、CPU      | 占用内存多，切换复杂，CPU利用率低                            | 占用内存少，切换简单，CPU利用率高                            |
| 创建销毁、切换 | 创建销毁、切换复杂，速度慢                                   | 创建销毁、切换简单，速度很快                                 |
| 编程、调试     | 编程简单，调试简单                                           | 编程复杂，调试复杂                                           |
| 可靠性         | 进程间不会互相影响                                           | 一个线程挂掉将导致整个进程挂掉                               |
| 分布式         | 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 | 适应于多核分布式                                             |



## 线程系统调用阻塞是否导致进程阻塞的问题

**问题： 如果一个进程中的某一个线程调用了一个阻塞的系统调用函数后，那么该进程包括该进程中的其他所有线程也同时被阻塞 ？**
关于这个问题。网上有些解答似乎比较混乱。回答这个问题，首先要简单了解一下线程模型。
线程模型（下述对应关系为 “线程”对“内核调度实体”）

- 多对1用户级线程模型
- 1对1内核级线程模型
- 多对多两级线程模型

### 多对1用户级线程模型

- 线程的创建、调度、同步，由所属进程的**用户空间线程库**实现。

- 用户态线程，对内核几乎是透明的（许多操作不需要内核接管）

- 但线程总要有一些操作经过内核，比如系统调用。

- 不需要频繁的内核态/用户态切换，处理速度非常快。

- **该模式下，当进程的某个线程，系统调用（比如I/O）阻塞时，该进程也会阻塞。**
- 原因：该模式下，进程的所有线程，都对应一个内核调度实体（KES），并且内核不知道这个进程有哪些线程。KES无法将其他线程，调度到其他处理器上。该进程（所有的线程）被阻塞，直到本次系统调用（比如I/O）结束。


### 1对1内核级线程模型

* 每个用户线程都对应一个的内核调度实体。
* **内核会对每个线程进行调度，可以调度到其他处理器上。**
* 线程每次操作会在用户态和内核态切换。
* 线程数量过多时，对系统性能有影响。

### 多对多两级线程模型

* 每个用户线程拥有多个内核调度实体
* 多个用户线程也可以对应一个内核调度实体
* 实现该模型非常复杂。

目前（linux）基本上都采用一对一模型。

### 总结

* 线程系统调用阻塞时，在多对1用户级线程模型下，会导致所属进程阻塞。
* 在1对1或多对多模型下，不会导致该问题的发生。
* 如果是单进程单线程的话，不管哪个模型，都会阻塞的。
  

#### **孤儿进程**

**一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。**

孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

#### **僵尸进程**

**一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。**

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程

#### **守护进程**

**Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。**它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。

守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。

一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。

守护进程的名称通常以d结尾，比如sshd、xinetd、crond等