# 进程、线程的区别和使用场景

## 1. 进程

- 进程是**系统进行资源分配和调度**的一个独立单位 。

- 程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。

- 在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。

  进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。

## 2. 线程

- 引入：为什么需要线程
  - 进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。
  - 进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。
  - 为了更好的使多道程序并发执行，提高资源利用率和吞吐量，增加程序的并发性。
- 线程是进程的一个实体，是**CPU调度和分派**的基本单位，它是比进程更小的能独立运行的基本单位。

## 3. 区别

- 进程**系统进行资源分配和调度**的一个独立单位 ；线程是**CPU调度和分派**的基本单位
- 线程是进程的一个实体，是比进程更小的能独立运行的基本单位
- 进程有独立的地址空间，切换开销大，多个进程需要同步和互斥手段；而线程没有独立的空间，线程只有自己的栈、程序计数器、寄存器，切换小，线程只需要读写全局变量
- ~~进程崩溃时不会对其他进程产生影响，线程崩溃时整个进程都会崩溃~~
- 操作系统可以同时运行多个进程；同一个进程中有多个线程在执行
- ~~进程切换、创建、销毁比较麻烦，线程比较简单~~
- 相同进程中线程的切换不会影响进程的切换，不同进程中线程的切换回引起进程的切换



## 4. 多进程和多线程的使用场景

| 对比维度       | 多进程                                                       | 多线程                                                       |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据共享、同步 | 数据共享复杂，需要用IPC；数据是分开的，同步简单              | 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 |
| 内存、CPU      | 占用内存多，切换复杂，CPU利用率低                            | 占用内存少，切换简单，CPU利用率高                            |
| 创建销毁、切换 | 创建销毁、切换复杂，速度慢                                   | 创建销毁、切换简单，速度很快                                 |
| 编程、调试     | 编程简单，调试简单                                           | 编程复杂，调试复杂                                           |
| 可靠性         | 进程间不会互相影响                                           | 一个线程挂掉将导致整个进程挂掉                               |
| 分布式         | 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 | 适应于多核分布式                                             |



## 线程系统调用阻塞是否导致进程阻塞的问题

**问题： 如果一个进程中的某一个线程调用了一个阻塞的系统调用函数后，那么该进程包括该进程中的其他所有线程也同时被阻塞 ？**
关于这个问题。网上有些解答似乎比较混乱。回答这个问题，首先要简单了解一下线程模型。
线程模型（下述对应关系为 “线程”对“内核调度实体”）

- 多对1用户级线程模型
- 1对1内核级线程模型
- 多对多两级线程模型

### 多对1用户级线程模型

- 线程的创建、调度、同步，由所属进程的**用户空间线程库**实现。

- 用户态线程，对内核几乎是透明的（许多操作不需要内核接管）

- 但线程总要有一些操作经过内核，比如系统调用。

- 不需要频繁的内核态/用户态切换，处理速度非常快。

- **该模式下，当进程的某个线程，系统调用（比如I/O）阻塞时，该进程也会阻塞。**
- 原因：该模式下，进程的所有线程，都对应一个内核调度实体（KES），并且内核不知道这个进程有哪些线程。KES无法将其他线程，调度到其他处理器上。该进程（所有的线程）被阻塞，直到本次系统调用（比如I/O）结束。


### 1对1内核级线程模型

* 每个用户线程都对应一个的内核调度实体。
* **内核会对每个线程进行调度，可以调度到其他处理器上。**
* 线程每次操作会在用户态和内核态切换。
* 线程数量过多时，对系统性能有影响。

### 多对多两级线程模型

* 每个用户线程拥有多个内核调度实体
* 多个用户线程也可以对应一个内核调度实体
* 实现该模型非常复杂。

目前（linux）基本上都采用一对一模型。

### 总结

* 线程系统调用阻塞时，在多对1用户级线程模型下，会导致所属进程阻塞。
* 在1对1或多对多模型下，不会导致该问题的发生。
* 如果是单进程单线程的话，不管哪个模型，都会阻塞的。
  

#### **孤儿进程**

**一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。**

孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

#### **僵尸进程**

**一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。**

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程

#### **守护进程**

**Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。**它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。

守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。

一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。

守护进程的名称通常以d结尾，比如sshd、xinetd、crond等