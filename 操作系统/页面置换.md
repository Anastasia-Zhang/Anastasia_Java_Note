# 简述页面置换算法及它们的异同

当进程运行过程中，发生缺页中断且此时内存中没有空闲的物理块，为了能够把所缺的页面装入内存，需要通过某种策略讲内存中的某一页放到磁盘的swap里去，这种策略就成为“页面置换算法”。接下来介绍几种不同的页面置换算法及它们的优劣。

## 1. OPT 最佳替换

- 基本思路

  **选择将来最迟才会被访问的页面**置换出去以保证获得最低的缺页率

- 算法实现

  缺页时，计算内存中每个逻辑页面的下一次访问时间；选择**未来最长时间不访问的页面淘汰**

- 评价

  - 因为是理想状态，所以缺页最少
  - 实际使用中无法预测未来最长时间不访问的页面

## 2. FIFO先进先出

- 基本思路

  优先淘汰最早进入内存的页面

- 算法实现

  把调入内存的页面根据先后次序连接成链表，当发生缺页时，将头节点的页面移出，新页面放入链尾

- 评价

  - 实现简单
  - 性能差，可能调出经常需要访问的页面
  - 可能产生**当分配的物理块数增大但缺页次数不减反增的异常现象**，这种现象被Belady发现，因此称为**Belady异常**

  > Belady异常的产生原因：
  >
  > - FIFO算法的置换特征与进程访问内存的动态特征矛盾
  > - 被它置换出去的页面并不一定是进程近期不会访问的
  >
  > 哪些置换算法没有Belady现象：
  >
  > 时钟置换算法，最近最久未使用算法，最佳置换算法

## 3. LRU 最近最久未使用

- 基本思路

  选择**当前内存中最长时间没有被访问的页面予以淘汰**，因为局部性可以让我们认为最长时间没被访问过的页面，接下来也可能不会被访问。

- 算法实现

  TODO，这是一个面试中很爱考的题，在这边三言两语也讲不完，之后会专门写一篇，补充链接到这个位置

  最近最久未使用置换算法(LRU)
  最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面
  实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自.上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。

  ![在这里插入图片描述](E:\研究生学习\Work\技术笔记\操作系统\页面置换.assets\20190606091415879.png)

  LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。

  在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。
  
- 评价

  - 开销大
  - OPT的一种近似

## 4. Clock 时钟替换

- 基本思路

  仅对页面的访问情况进行大致统计，选择最近未被使用的页面

- 算法实现

  - 页面装入内存时，访问位初始化为0
  - 访问页面（读/写)时，访问位置1
  - 缺页时，从指针当前位置顺序检查环形链表
    - 访问位为0，则置换该页
    - 访问位为1，则访问位置0，并指针移动到下一个页面，直到找到可置换的页面

- 评价

  开销比LRU小，性能比FIFO高