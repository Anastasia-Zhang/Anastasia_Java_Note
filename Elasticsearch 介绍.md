# Elasticsearch 介绍

### 用途

Elasticsearch 在速度和可扩展性方面都表现出色，而且还能够索引多种类型的内容，这意味着其可用于多种用例：

- 应用程序搜索
- 网站搜索
- 企业搜索
- 日志处理和分析
- 基础设施指标和容器监测
- 应用程序性能监测
- 地理空间数据分析和可视化
- 安全分析
- 业务分析

## 处理数据：查询和分析

虽然您可以使用Elasticsearch作为文档存储和检索文档及其元数据，但真正强大的功能来自于能够轻松访问Apache Lucene搜索引擎库上构建的全套搜索功能。

**Elasticsearch提供了一个简单、一致的REST API，用于管理集群、索引和搜索数据**。出于测试目的，您可以直接从命令行或通过Kibana中的开发人员控制台轻松地提交请求。在您的应用程序中，您可以使用Elasticsearch客户端来选择您的语言:Java、JavaScript、Go、.NET、PHP、Python

### 查询

Elasticsearch REST api支持结构化查询、全文查询和组合这两者的复杂查询。结构化查询类似于您可以在SQL中构造的查询类型。例如，您可以在员工索引中搜索性别和年龄字段，并根据hire_date字段对匹配项进行排序。全文查询查找与查询字符串匹配的所有文档，并按相关度返回它们——它们与搜索条件的匹配程度。

### 聚合

Elasticsearch聚合使您能够构建数据的复杂摘要，并深入了解关键指标、模式和趋势。因为聚合利用了用于搜索的相同数据结构，所以它们的速度也非常快。这使您能够实时分析和可视化您的数据。您的报告和仪表板会随着数据的更改而更新，以便您可以根据最新的信息采取行动。

更重要的是，聚合与搜索请求一起运行。您可以在单个请求中搜索文档、过滤结果并同时对相同的数据执行分析。

## 基本概念

### 节点 Node、集群 Cluster 和分片 Shards

ElasticSearch 是分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个实例。单个实例称为一个节点（node），一组节点构成一个集群（cluster）。分片是底层的工作单元，文档保存在分片内，分片又被分配到集群内的各个节点里，每个分片仅保存全部数据的一部分。

我们可以向集群中添加服务器(节点)来增加容量，Elasticsearch会自动将您的数据和查询负载分布到所有可用节点上。

实际上，Elasticsearch索引只是一个或多个物理分片的逻辑分组，其中每个分片实际上是一个自包含的索引。也就是说，索引可以被拆分为多个分片，每个分片存储部分数据。通过跨多个分片将文档分布在一个索引中，并将这些分片分布在多个节点上，Elasticsearch可以确保冗余，这既可以防止硬件故障，又可以在节点添加到集群时增加查询能力。（**支持横向扩展和提高性能**）随着集群的增长(或收缩)，Elasticsearch会自动迁移碎片来重新平衡集群。

接着就是这个 shard 的数据实际是有多个备份，就是说每个 shard 都有一个 `primary shard`，负责写入数据，但是还有几个 `replica shard`。`primary shard` 写入数据之后，会将数据同步到其他几个 `replica shard` 上去。提供数据副本防止节点故障。

索引中主碎片的数量在创建索引时是固定的，但是复制碎片的数量可以在任何时候更改，而不会中断索引或查询操作。

![es-cluster](https://github.com/Anastasia-Zhang/advanced-java/raw/master/images/es-cluster.png)

### 分片大小的确定

以下是关于分片大小和为索引配置的主分片数量的一些性能考虑和权衡。分片越多，维护这些索引的开销就越大。当Elasticsearch需要重新平衡集群时，碎片大小越大，碎片移动所需的时间越长。

查询大量的小碎片会使每个碎片的处理速度更快，但是更多的查询意味着更多的开销，因此查询较少数量的较大碎片可能会更快。简而言之，这要看情况。

通常取决于

* 目标是将碎片的平均大小保持在几GB到几十GB之间。对于具有基于时间的数据的用例，通常会看到20GB到40GB范围内的碎片。

* 避免大量碎片的问题。一个节点可以容纳的碎片的数量与可用的堆空间成比例。一般来说，每GB堆空间的碎片数应该小于20

### 索引 Index、类型 Type 和文档 Document

* Elasticsearch是一个分布式文档存储。存储已序列化为JSON文档的复杂数据结构。每个文档都会在一组*键*（字段或属性的名称）和它们对应的值（字符串、数字、布尔值、日期、数值组、地理位置或其他类型的数据）之间建立联系。当一个集群中有多个Elasticsearch节点时，存储的文档分布在整个集群中，可以从任何节点立即访问它们
* 当一个文档被存储时，它会被索引，并且可以在1秒内被完全实时搜索到。Elasticsearch使用一种称为**反向索引的数据结构**，支持非常快速的全文搜索。**反向索引列出任何文档中出现的每个唯一单词，并标识每个单词所在的所有文档。**
* 可以将索引看作是文档的优化集合，每个文档都是字段的集合，字段是包含数据的键-值对。默认情况下，Elasticsearch对每个字段中的所有数据进行索引，每个索引字段都有一个专用的优化数据结构。例如，文本字段存储在反向索引中，数字和地理字段存储在BKD树中。使用每个字段的数据结构来组装和返回搜索结果的能力是Elasticsearch如此快速的原因。

在索引过程中，Elasticsearch 会存储文档并构建倒排索引，这样用户便可以近实时地对文档数据进行搜索。索引过程是在索引 API 中启动的，通过此 API 您既可向特定索引中添加 JSON 文档，也可更改特定索引中的 JSON 文档。

具体的介绍可以看华中石杉里讲的：https://github.com/Anastasia-Zhang/advanced-java/blob/master/docs/high-concurrency/es-architecture.md

ES 中存储数据的**基本单位是索引**，比如说你现在要在 es 中存储一些订单数据，你就应该在 es 中创建一个索引 `order_idx`，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是 mysql 里的一张表。

```
index -> type -> mapping -> document -> field。
```

这样吧，为了做个更直白的介绍，我在这里做个类比。但是切记，不要划等号，类比只是为了便于理解。

index 相当于 mysql 里的一张表。而 type 没法跟 mysql 里去对比，一个 index 里可以有多个 type，每个 type 的字段都是差不多的，但是有一些略微的差别。假设有一个 index，是订单 index，里面专门是放订单数据的。就好比说你在 mysql 中建表，有些订单是实物商品的订单，比如一件衣服、一双鞋子；有些订单是虚拟商品的订单，比如游戏点卡，话费充值。就两种订单大部分字段是一样的，但是少部分字段可能有略微的一些差别。

所以就会在订单 index 里，建两个 type，一个是实物商品订单 type，一个是虚拟商品订单 type，这两个 type 大部分字段是一样的，少部分字段是不一样的。

很多情况下，一个 index 里可能就一个 type，但是确实如果说是一个 index 里有多个 type 的情况（**注意**，`mapping types` 这个概念在 ElasticSearch 7.X 已被完全移除，详细说明可以参考[官方文档](https://github.com/elastic/elasticsearch/blob/6.5/docs/reference/mapping/removal_of_types.asciidoc)），你可以认为 index 是一个类别的表，具体的每个 type 代表了 mysql 中的一个表。每个 type 有一个 mapping，如果你认为一个 type 是具体的一个表，index 就代表多个 type 同属于的一个类型，而 mapping 就是这个 type 的**表结构定义**，你在 mysql 中创建一个表，肯定是要定义表结构的，里面有哪些字段，每个字段是什么类型。实际上你往 index 里的一个 type 里面写的一条数据，叫做一条 document，一条 document 就代表了 mysql 中某个表里的一行，每个 document 有多个 field，每个 field 就代表了这个 document 中的一个字段的值。

## 使用 RESTful API 与 Elasticsearch交互

```
curl -X<verb> '<protocol>://<host>:<port>/<path>?<query_string>' -d '<body>'
```

| 部件                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| **`<VERB>`**         | 适当的 HTTP 方法 或 谓词 : `GET`、 `POST`、 `PUT`、 `HEAD` 或者 `DELETE`。 |
| **`<PROTOCOL>`**     | http或https。如果在Elasticsearch前面有一个HTTPS代理，或者使用Elasticsearch安全特性加密HTTP通信，则使用后者。 |
| **`<HOST>`**         | Elasticsearch集群中任何节点的主机名。或者，在您的本地机器上使用localhost作为节点。 |
| **`<PORT>`**         | 端口，默认9200                                               |
| **`<PATH>`**         | API 的终端路径（例如 `_count` 将返回集群中文档数量）。Path 可能包含多个组件，例如：`_cluster/stats` 和 `_nodes/stats/jvm` 。 |
| **`<QUERY_STRING>`** | 任意可选的查询字符串参数 (例如 `?pretty` 将格式化地输出 JSON 返回值，使其更容易阅读) |
| **`<BODY>`**         | 一个 JSON 格式的请求体 (如果请求需要的话)                    |

计算集群中文档的数量

```json
curl -XGET 'http://localhost:9200/_count?pretty' -d '
{
    "query": {
        "match_all": {}
    }
}
'
```

